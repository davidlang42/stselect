use std::{env, error::Error, fs};
use crate::syncthing::{IgnoreFile, SubFolder, FilesMoved};

mod syncthing;

fn main() -> Result<(), Box<dyn Error>> {
    let mut args = env::args();
    let cmd = args.next().unwrap();
    match args.next() {
        Some(s) => verb(&cmd, &s, args.collect()),
        None => interactive(".")
    }
}

fn help(cmd: &str) -> Result<(), Box<dyn Error>> {
    println!("Usage:");
    println!("  {} [PATH] -- open an interactive editor for which folders to sync", cmd);
    println!("  {} list [PATH] -- list the folders currently selected to sync", cmd);
    println!("  {} include [PATH] [SUB_FOLDER] -- enable syncing of SUB_FOLDER", cmd);
    println!("  {} exclude [PATH] [SUB_FOLDER] -- disable syncing of SUB_FOLDER", cmd);
    println!("  {} all [PATH] -- enable syncing of all sub folders", cmd);
    println!("  {} none [PATH] -- disable syncing of all sub folders", cmd);
    println!("Omit PATH to use current directory, or omit PATH and SUB_FOLDER to use current directory as SUB_FOLDER and its parent as PATH");
    Ok(())
}

fn verb(cmd: &str, verb: &str, args: Vec<String>) -> Result<(), Box<dyn Error>> {
    match verb {
        "list" if args.len() == 0 => list("."),
        "list" if args.len() == 1 => list(&args[0]),
        "clean" if args.len() == 0 => run_clean("."),
        "clean" if args.len() == 1 => run_clean(&args[0]),
        "include" if args.len() == 0 => set_folder("..", &current_sub_folder()?, true),
        "include" if args.len() == 1 => set_folder(".", &args[0], true),
        "include" if args.len() == 2 => set_folder(&args[0], &args[1], true),
        "exclude" if args.len() == 0 => set_folder("..", &current_sub_folder()?, false),
        "exclude" if args.len() == 1 => set_folder(".", &args[0], false),
        "exclude" if args.len() == 2 => set_folder(&args[0], &args[1], false),
        "all" if args.len() == 0 => set_all(".", true),
        "all" if args.len() == 1 => set_all(&args[0], true),
        "none" if args.len() == 0 => set_all(".", false),
        "none" if args.len() == 1 => set_all(&args[0], false),
        "help" => help(cmd),
        "-h" => help(cmd),
        "/?" => help(cmd),
        path if args.len() == 0 => interactive(path),
        _ => help(cmd)
    }
}

fn list(path: &str) -> Result<(), Box<dyn Error>> {
    let ignore = IgnoreFile::open(path)?;
    warn(&ignore);
    print_folders(&mut ignore.folders.iter());
    println!("{} of {} sub folders selected to sync", ignore.folders.iter().filter(|f| f.selected).count(), ignore.folders.len());
    if ignore.removed.len() > 0 {
        println!("(and {} of {} sub folders which have since been deleted)", ignore.removed.iter().filter(|f| f.selected).count(), ignore.removed.len());
    }
    list_cleaned(ignore.list_redundant_files()?, true)
}

fn run_clean(path: &str) -> Result<(), Box<dyn Error>> {
    let ignore = IgnoreFile::open(path)?;
    warn(&ignore);
    let added: Vec<&SubFolder> = ignore.folders.iter().filter(|f| f.assumed).collect();
    if added.len() > 0 {
        println!("The following new sub {} been added:", if added.len() == 1 { "folder has" } else { "folders have" });
        print_folders(&mut added.into_iter());
    }
    list_removed(&ignore);
    ignore.save()?;
    list_cleaned(ignore.clean_redundant_files()?, false)
}

fn set_folder(path: &str, sub_folder: &str, value: bool) -> Result<(), Box<dyn Error>> {
    let mut ignore = IgnoreFile::open(path)?;
    warn(&ignore);
    ignore.set(sub_folder, value)?;
    println!("{} '{}' for syncing", selected(value), sub_folder);
    list_removed(&ignore);
    ignore.save()?;
    list_cleaned(ignore.clean_redundant_files()?, false)
}

fn set_all(path: &str, value: bool) -> Result<(), Box<dyn Error>> {
    let mut ignore = IgnoreFile::open(path)?;
    warn(&ignore);
    for folder in ignore.folders.iter_mut() {
        folder.selected = value;
    }
    println!("{} all {} sub folders for syncing", selected(value), ignore.folders.len());
    list_removed(&ignore);
    ignore.save()?;
    list_cleaned(ignore.clean_redundant_files()?, false)
}

fn list_cleaned(moved: Option<FilesMoved>, dry_run: bool) -> Result<(), Box<dyn Error>> {
    if let Some(files) = moved {
        if dry_run {
            println!("WARNING: Found non-synced files:");
        } else {
            println!("Moved non-synced files to {}", files.to_path.display());
        }
        for (folder, count) in files.count_by_folder {
            println!("- {}: {} files totalling {}", folder.name, count.files, count.size());
        }
    }
    Ok(())
}

fn selected(value: bool) -> &'static str {
    if value {
        "Selected"
    } else {
        "Unselected"
    }
}

fn warn(ignore: &IgnoreFile) {
    let mut warnings = Vec::new();
    if !ignore.previously_generated {
        warnings.push(format!("was NOT previously generated by stselect"));
    }
    if ignore.passthrough.len() > 0 {
        warnings.push(format!("contains {} passed through lines", ignore.passthrough.len()));
    }
    if warnings.len() > 0 {
        println!("NOTE: The ignore file {}", warnings.join(" and "));
    }
}

fn print_folders(folders: &mut dyn Iterator<Item = &SubFolder>) {
    for folder in folders {
        let selected = if folder.selected {
            'x'
        } else {
            ' '
        };
        let assumed = if folder.assumed {
            " (assumed)"
        } else {
            ""
        };
        println!("[{}] {}{}", selected, folder.name, assumed);
    }
}

fn list_removed(ignore: &IgnoreFile) {
    if ignore.removed.len() > 0 {
        println!("The following deleted sub {} been removed:", if ignore.removed.len() == 1 { "folder has" } else { "folders have" });
        print_folders(&mut ignore.removed.iter());
    }
}

fn current_sub_folder() -> Result<String, Box<dyn Error>> {
    let wd = fs::canonicalize(".")?;
    Ok(wd.file_name().unwrap().to_str().unwrap().to_string())
}

fn interactive(_path: &str) -> Result<(), Box<dyn Error>> {
    println!("TODO: Interactive mode not implemented yet.");
    help("stselect")
}