use std::{env, error::Error, fs};
use crate::syncthing::{IgnoreFile, SubFolder};

mod syncthing;

fn main() -> Result<(), Box<dyn Error>> {
    let mut args = env::args();
    let cmd = args.next().unwrap();
    match args.next() {
        Some(s) => verb(cmd, &s, args.collect()),
        None => help(cmd)
    }
}

fn help(cmd: String) -> Result<(), Box<dyn Error>> {
    println!("Usage:");
    println!("  {} [PATH] -- open an interactive editor for which folders to sync", cmd);
    println!("  {} list [PATH] -- list the folders currently selected to sync", cmd);
    println!("  {} include [PATH] [SUB_FOLDER] -- enable syncing of SUB_FOLDER", cmd);
    println!("  {} exclude [PATH] [SUB_FOLDER] -- disable syncing of SUB_FOLDER", cmd);
    println!("  {} all [PATH] -- enable syncing of all sub folders", cmd);
    println!("  {} none [PATH] -- disable syncing of all sub folders", cmd);
    println!("Omit PATH to use current directory, or omit PATH and SUB_FOLDER to use current directory as SUB_FOLDER and its parent as PATH");
    Ok(())
}

fn verb(cmd: String, verb: &str, args: Vec<String>) -> Result<(), Box<dyn Error>> {
    match verb {
        "list" if args.len() == 0 => list("."),
        "list" if args.len() == 1 => list(&args[0]),
        "include" if args.len() == 0 => set_folder("..", &current_sub_folder()?, true),
        "include" if args.len() == 1 => set_folder(".", &args[0], true),
        "include" if args.len() == 2 => set_folder(&args[0], &args[1], true),
        "exclude" if args.len() == 0 => set_folder("..", &current_sub_folder()?, false),
        "exclude" if args.len() == 1 => set_folder(".", &args[0], false),
        "exclude" if args.len() == 2 => set_folder(&args[0], &args[1], false),
        "all" if args.len() == 0 => set_all(".", true),
        "all" if args.len() == 1 => set_all(&args[0], true),
        "none" if args.len() == 0 => set_all(".", false),
        "none" if args.len() == 1 => set_all(&args[0], false),
        "help" => help(cmd),
        "-h" => help(cmd),
        _ if args.len() == 0 => interactive("."),
        _ if args.len() == 1 => interactive(&args[0]),
        _ => help(cmd)
    }
}

fn list(path: &str) -> Result<(), Box<dyn Error>> {
    let ignore = IgnoreFile::open(path)?;
    warn(&ignore);
    for folder in &ignore.folders {
        print_folder(folder);
    }
    println!("{} of {} sub folders selected to sync", ignore.folders.iter().filter(|f| f.selected).count(), ignore.folders.len());
    if ignore.removed.len() > 0 {
        println!("(and {} of {} sub folders which have since been deleted)", ignore.removed.iter().filter(|f| f.selected).count(), ignore.removed.len());
    }
    Ok(())
}

fn set_folder(path: &str, sub_folder: &str, value: bool) -> Result<(), Box<dyn Error>> {
    let mut ignore = IgnoreFile::open(path)?;
    warn(&ignore);
    ignore.set(sub_folder, value)?;
    println!("{} '{}' for syncing", selected(value), sub_folder);
    list_removed(&ignore);
    ignore.save()
}

fn set_all(path: &str, value: bool) -> Result<(), Box<dyn Error>> {
    let mut ignore = IgnoreFile::open(path)?;
    warn(&ignore);
    for folder in ignore.folders.iter_mut() {
        folder.selected = value;
    }
    println!("{} all {} sub folders for syncing", selected(value), ignore.folders.len());
    list_removed(&ignore);
    ignore.save()
}

fn selected(value: bool) -> &'static str {
    if value {
        "Selected"
    } else {
        "Unselected"
    }
}

fn interactive(_path: &str) -> Result<(), Box<dyn Error>> {
    todo!()
}

fn warn(ignore: &IgnoreFile) {
    let mut warnings = Vec::new();
    if !ignore.previously_generated {
        warnings.push(format!("was NOT previously generated by stselect"));
    }
    if ignore.passthrough.len() > 0 {
        warnings.push(format!("contains {} passed through lines", ignore.passthrough.len()));
    }
    if warnings.len() > 0 {
        println!("NOTE: The ignore file {}", warnings.join(" and "));
    }
}

fn print_folder(folder: &SubFolder) {
    let selected = if folder.selected {
        'x'
    } else {
        ' '
    };
    let assumed = if folder.assumed {
        " (assumed)"
    } else {
        ""
    };
    println!("[{}] {}{}", selected, folder.name, assumed);
}

fn list_removed(ignore: &IgnoreFile) {
    if ignore.removed.len() > 0 {
        println!("The following deleted sub folders have removed:");
        for folder in &ignore.removed {
            print_folder(folder);
        }
    }
}

fn current_sub_folder() -> Result<String, Box<dyn Error>> {
    let wd = fs::canonicalize(".")?;
    Ok(wd.file_name().unwrap().to_str().unwrap().to_string())
}