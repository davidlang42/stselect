use std::collections::HashMap;
use std::fs;
use std::error::Error;
use std::path::PathBuf;
use std::path;
use std::fmt;
use std::str::FromStr;
use std::io::Write;
use chrono;

pub struct SubFolder {
    pub name: String,
    pub selected: bool,
    pub assumed: bool
}

pub struct IgnoreFile {
    pub folders: Vec<SubFolder>,
    pub removed: Vec<SubFolder>,
    pub passthrough : Vec<String>,
    pub previously_generated: bool,
    filename: Option<PathBuf>
}

pub enum SyncthingError {
    MissingStFolder(String),
    SubFolderNotFound(String),
    FilenameRequired
}

pub struct FilesMoved<'a> {
    pub count_by_folder: Vec<(&'a SubFolder, FileCount)>,
    pub to_path: PathBuf
}

pub struct FileCount {
    pub files: usize,
    pub bytes: u64
}

const STFOLDER: &str = ".stfolder";
const STIGNORE: &str = ".stignore";
const STVERSIONS: &str = ".stversions";
const FIRST_LINE_PREFIX: &str = "# Generated by stselect";
const SECOND_LINE: &str = WARNING_FILE;
const WARNING_FILE: &str = "WARNING_SUB_FOLDER_NOT_SYNCED";
const FINAL_LINE: &str = "/*/**";
const IGNORE_DIRS: [&str; 2] = [STVERSIONS, STFOLDER];
const IGNORE_FILES: [&str; 1] = [WARNING_FILE];

impl fmt::Display for SyncthingError {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        match self {
            SyncthingError::MissingStFolder(path) => write!(f, "Not a syncthing folder: {}", path),
            SyncthingError::SubFolderNotFound(sub_folder) => write!(f, "Sub folder not found: {}", sub_folder),
            SyncthingError::FilenameRequired => write!(f, "Filename required to save {}", STIGNORE)
        }
    }
}

impl fmt::Debug for SyncthingError {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        write!(f, "{}", self)
    }
}

impl Error for SyncthingError { }

impl fmt::Display for SubFolder {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        if !self.selected {
            write!(f, "#")?;
        }
        write!(f, "!/{}", self.name)
    }
}

impl FromStr for SubFolder {
    type Err = String;

    fn from_str(s: &str) -> Result<Self, Self::Err> {
        if s.len() >= 3 && &s[0..2] == "!/" && !s[2..].contains(path::MAIN_SEPARATOR) {
            Ok(Self {
                name: s[2..].to_string(),
                selected: true,
                assumed: false
            })
        } else if s.len() >= 4 && &s[0..3] == "#!/" && !s[3..].contains(path::MAIN_SEPARATOR) {
            Ok(Self {
                name: s[3..].to_string(),
                selected: false,
                assumed: false
            })
        } else {
            Err(format!("Invalid line: {}", s))
        }
    }
}

impl fmt::Display for IgnoreFile {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        writeln!(f, "{} at {}", FIRST_LINE_PREFIX, chrono::offset::Local::now().format("%Y-%m-%d %H:%M:%S"))?;
        writeln!(f, "{}", SECOND_LINE)?;
        for line in &self.passthrough {
            writeln!(f, "{}", line)?;
        }
        for folder in &self.folders {
            writeln!(f, "{}", folder)?;
        }
        writeln!(f, "{}", FINAL_LINE)
    }
}

impl FromStr for IgnoreFile {
    type Err = String;

    fn from_str(s: &str) -> Result<Self, Self::Err> {
        let mut folders = Vec::new();
        let mut passthrough = Vec::new();
        let mut previously_generated = false;
        let mut second_line = false;
        let mut final_line = false;
        for line in s.lines() {
            if final_line {
                return Err(format!("More than one FINAL_LINE"));
            } else if line.starts_with(FIRST_LINE_PREFIX) {
                if previously_generated {
                    return Err(format!("More than one FIRST_LINE_PREFIX"));
                }
                previously_generated = true;
            } else if line == SECOND_LINE {
                if !previously_generated {
                    return Err(format!("SECOND_LINE before FIRST_LINE_PREFIX"));
                }
                if second_line {
                    return Err(format!("More than one SECOND_LINE"));
                }
                second_line = true;
            } else if line == FINAL_LINE {
                final_line = true;
            } else if let Ok(sub_folder) = line.parse() {
                folders.push(sub_folder);
            } else {
                passthrough.push(line.to_string());
            }
        }
        Ok(Self {
            previously_generated,
            filename: None,
            folders,
            passthrough,
            removed: Vec::new()
        })
    }
}

impl IgnoreFile {
    pub fn open(root_folder_path: &str) -> Result<Self, Box<dyn Error>> {
        let path = PathBuf::from(root_folder_path);
        // check stfolder
        let mut stfolder = path.clone();
        stfolder.push(STFOLDER);
        if !stfolder.exists() || !fs::metadata(stfolder)?.is_dir() {
            return Err(Box::new(SyncthingError::MissingStFolder(root_folder_path.to_string())));
        }
        // load existing ignores
        let mut filename = path.clone();
        filename.push(STIGNORE);
        let mut ignore = if filename.exists() {
            fs::read_to_string(filename.as_path())?.parse()?
        } else {
            IgnoreFile {
                previously_generated: false,
                filename: None,
                folders: Vec::new(),
                removed: Vec::new(),
                passthrough: Vec::new()
            }
        };
        ignore.filename = Some(filename);
        // compare with actual folders
        let mut actual = ls(&path, true, false)?;
        for ignore_dir in IGNORE_DIRS {
            actual.remove(ignore_dir);
        }
        let mut i = 0;
        while i < ignore.folders.len() {
            if !actual.contains_key(&ignore.folders[i].name) {
                ignore.removed.push(ignore.folders.remove(i));
            } else {
                i += 1;
            }
        }
        for (name, _) in actual {
            if ignore.folders.iter().position(|f| f.name == name).is_none() {
                let f = SubFolder {
                    name,
                    selected: false,
                    assumed: true
                };
                ignore.folders.push(f);
            }
        }
        // sort and return
        ignore.folders.sort_by(|a,b| a.name.cmp(&b.name));
        ignore.removed.sort_by(|a,b| a.name.cmp(&b.name));
        Ok(ignore)
    }

    pub fn set(&mut self, sub_folder: &str, value: bool) -> Result<(), Box<dyn Error>> {
        for sf in &mut self.folders {
            if sf.name == sub_folder {
                sf.selected = value;
                return Ok(());
            }
        }
        Err(Box::new(SyncthingError::SubFolderNotFound(sub_folder.to_string())))
    }

    pub fn save(&self) -> Result<(), Box<dyn Error>> {
        if let Some(filename) = &self.filename {
            if filename.exists() {
                let mut move_to = filename.with_file_name(STVERSIONS);
                if !move_to.exists() {
                    fs::create_dir(&move_to)?;
                }
                if fs::metadata(&move_to)?.is_dir() {
                    move_to.push(format!("{}_{}", STIGNORE, chrono::offset::Local::now().format("%Y-%m-%d_%H%M%S")));
                    fs::rename(filename, move_to)?;
                }
            }
            for folder in &self.folders {
                let mut warning = filename.with_file_name(&folder.name);
                warning.push(WARNING_FILE);
                if folder.selected && warning.exists() && warning.is_file() {
                    fs::remove_file(warning)?;
                } else if !folder.selected && !warning.exists() {
                    fs::File::create(warning)?;
                }
            }
            let mut f = fs::File::options().write(true).create(true).open(filename)?;
            write!(f, "{}", self)?;
            f.flush()?;
            Ok(())
        } else {
            Err(Box::new(SyncthingError::FilenameRequired))
        }
    }

    pub fn clean_redundant_files(&self) -> Result<Option<FilesMoved>, Box<dyn Error>> {
        self.clean(false)
    }

    pub fn list_redundant_files(&self) -> Result<Option<FilesMoved>, Box<dyn Error>> {
        self.clean(true)
    }

    fn clean(&self, dry_run: bool) -> Result<Option<FilesMoved>, Box<dyn Error>> {
        if let Some(filename) = &self.filename {
            let stversions = filename.with_file_name(STVERSIONS);
            let mut counts = Vec::new();
            for folder in self.folders.iter().filter(|f| !f.selected) {
                let path = filename.with_file_name(&folder.name);
                let mut entries = ls(&path, true, true)?;
                for ignore_file in IGNORE_FILES {
                    entries.remove(ignore_file);
                }
                if entries.len() > 0 {
                    let mut move_to = stversions.clone();
                    move_to.push(&folder.name);
                    let mut i = 0;
                    while move_to.exists() {
                        move_to.set_file_name(format!("{}.{}", folder.name, i));
                        i += 1;
                    }
                    if !dry_run {
                        fs::create_dir(&move_to)?;
                    }
                    let mut count = FileCount::new();
                    for (name, entry) in entries {
                        count.add(&entry)?;
                        if !dry_run {
                            let mut this_to = move_to.clone();
                            this_to.push(name);
                            fs::rename(entry.path(), this_to)?;
                        }
                    }
                    counts.push((folder, count));
                }
            }
            Ok(if counts.len() > 0 {
                Some(FilesMoved {
                    count_by_folder: counts,
                    to_path: stversions
                })
            } else {
                None
            })
        } else {
            Err(Box::new(SyncthingError::FilenameRequired))
        }
    }
}

impl FileCount {
    fn new() -> Self {
        Self {
            files: 0,
            bytes: 0
        }
    }

    fn add(&mut self, file_or_folder: &fs::DirEntry) -> Result<(), Box<dyn Error>> {
        let metadata = file_or_folder.metadata()?;
        if metadata.is_dir() {
            for sub in fs::read_dir(file_or_folder.path())? {
                self.add(&sub?)?;
            }
        } else {
            self.files += 1;
            self.bytes += metadata.len();
        }
        Ok(())
    }

    pub fn size(&self) -> String {
        const SI_PREFIX: [char; 5] = ['\0', 'k', 'm', 'g', 't'];
        let mut i = 0;
        let mut n = self.bytes as f64;
        while n > 1024.0 && i < SI_PREFIX.len() {
            i += 1;
            n /= 1024.0;
        }
        format!("{:.1} {}b", n, SI_PREFIX[i])
    }
}

fn ls(path: &PathBuf, include_dir: bool, include_files: bool) -> Result<HashMap<String, fs::DirEntry>, Box<dyn Error>> {
    let mut results = HashMap::new();
    for entry in fs::read_dir(path)? {
        let existing = entry?;
        let metadata = existing.metadata()?;
        if include_dir && metadata.is_dir() || include_files && metadata.is_file() {
            if let Some(file_name) = existing.path().file_name() {
                if let Some(s) = file_name.to_str() {
                    results.insert(s.to_string(), existing);
                }
            }
        }
    }
    Ok(results)
}