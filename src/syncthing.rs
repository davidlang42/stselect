use std::collections::HashSet;
use std::fs;
use std::error::Error;
use std::path::PathBuf;
use std::path;
use std::fmt;
use std::str::FromStr;
use std::io::Write;
use chrono;

pub struct SubFolder {
    pub name: String,
    pub selected: bool,
    pub assumed: bool
}

pub struct IgnoreFile {
    pub folders: Vec<SubFolder>,
    pub removed: Vec<SubFolder>,
    pub passthrough : Vec<String>,
    pub previously_generated: bool,
    filename: Option<PathBuf>
}

pub enum SyncthingError {
    MissingStFolder(String),
    SubFolderNotFound(String),
    FilenameRequired
}

const STFOLDER: &str = ".stfolder";
const STIGNORE: &str = ".stignore";
const STVERSIONS: &str = ".stversions";
const FIRST_LINE_PREFIX: &str = "# Generated by stselect";
const FINAL_LINE: &str = "/*/**";
const IGNORE_DIRS: [&str; 2] = [STVERSIONS, STFOLDER];

impl fmt::Display for SyncthingError {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        match self {
            SyncthingError::MissingStFolder(path) => write!(f, "Not a syncthing folder: {}", path),
            SyncthingError::SubFolderNotFound(sub_folder) => write!(f, "Sub folder not found: {}", sub_folder),
            SyncthingError::FilenameRequired => write!(f, "Filename required to save {}", STIGNORE)
        }
    }
}

impl fmt::Debug for SyncthingError {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        write!(f, "{}", self)
    }
}

impl Error for SyncthingError { }

impl fmt::Display for SubFolder {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        if !self.selected {
            write!(f, "#")?;
        }
        write!(f, "!/{}", self.name)
    }
}

impl FromStr for SubFolder {
    type Err = String;

    fn from_str(s: &str) -> Result<Self, Self::Err> {
        if s.len() >= 3 && &s[0..2] == "!/" && !s[2..].contains(path::MAIN_SEPARATOR) {
            Ok(Self {
                name: s[2..].to_string(),
                selected: true,
                assumed: false
            })
        } else if s.len() >= 4 && &s[0..3] == "#!/" && !s[3..].contains(path::MAIN_SEPARATOR) {
            Ok(Self {
                name: s[3..].to_string(),
                selected: false,
                assumed: false
            })
        } else {
            Err(format!("Invalid line: {}", s))
        }
    }
}

impl fmt::Display for IgnoreFile {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        writeln!(f, "{} at {}", FIRST_LINE_PREFIX, chrono::offset::Local::now().format("%Y-%m-%d %H:%M:%S"))?;
        for line in &self.passthrough {
            writeln!(f, "{}", line)?;
        }
        for folder in &self.folders {
            writeln!(f, "{}", folder)?;
        }
        writeln!(f, "{}", FINAL_LINE)
    }
}

impl FromStr for IgnoreFile {
    type Err = String;

    fn from_str(s: &str) -> Result<Self, Self::Err> {
        let mut folders = Vec::new();
        let mut passthrough = Vec::new();
        let mut previously_generated = false;
        let mut final_line = false;
        for line in s.lines() {
            if final_line {
                return Err(format!("More than one FINAL_LINE"));
            } else if line.starts_with(FIRST_LINE_PREFIX) {
                if previously_generated {
                    return Err(format!("More than one FIRST_LINE_PREFIX"));
                }
                previously_generated = true;
            } else if line == FINAL_LINE {
                final_line = true;
            } else if let Ok(sub_folder) = line.parse() {
                folders.push(sub_folder);
            } else {
                passthrough.push(line.to_string());
            }
        }
        Ok(Self {
            previously_generated,
            filename: None,
            folders,
            passthrough,
            removed: Vec::new()
        })
    }
}

impl IgnoreFile {
    pub fn open(root_folder_path: &str) -> Result<Self, Box<dyn Error>> {
        let path = PathBuf::from(root_folder_path);
        // check stfolder
        let mut stfolder = path.clone();
        stfolder.push(STFOLDER);
        if !stfolder.exists() || !fs::metadata(stfolder)?.is_dir() {
            return Err(Box::new(SyncthingError::MissingStFolder(root_folder_path.to_string())));
        }
        // load existing ignores
        let mut filename = path.clone();
        filename.push(STIGNORE);
        let mut ignore = if filename.exists() {
            fs::read_to_string(filename.as_path())?.parse()?
        } else {
            IgnoreFile {
                previously_generated: false,
                filename: None,
                folders: Vec::new(),
                removed: Vec::new(),
                passthrough: Vec::new()
            }
        };
        ignore.filename = Some(filename);
        // compare with actual folders
        let mut actual = ls(&path, true, false)?;
        for ignore_dir in IGNORE_DIRS {
            actual.remove(ignore_dir);
        }
        let mut i = 0;
        while i < ignore.folders.len() {
            if !actual.contains(&ignore.folders[i].name) {
                ignore.removed.push(ignore.folders.remove(i));
            } else {
                i += 1;
            }
        }
        for name in actual {
            if ignore.folders.iter().position(|f| f.name == name).is_none() {
                let f = SubFolder {
                    name,
                    selected: true,
                    assumed: true
                };
                ignore.folders.push(f);
            }
        }
        // sort and return
        ignore.folders.sort_by(|a,b| a.name.cmp(&b.name));
        ignore.removed.sort_by(|a,b| a.name.cmp(&b.name));
        Ok(ignore)
    }

    pub fn set(&mut self, sub_folder: &str, value: bool) -> Result<(), Box<dyn Error>> {
        for sf in &mut self.folders {
            if sf.name == sub_folder {
                sf.selected = value;
                return Ok(());
            }
        }
        Err(Box::new(SyncthingError::SubFolderNotFound(sub_folder.to_string())))
    }

    pub fn save(&self) -> Result<(), Box<dyn Error>> {
        if let Some(filename) = &self.filename {
            if filename.exists() {
                let mut move_to = filename.with_file_name(STVERSIONS);
                if !move_to.exists() {
                    fs::create_dir(&move_to)?;
                }
                if fs::metadata(&move_to)?.is_dir() {
                    move_to.push(format!("{}_{}", STIGNORE, chrono::offset::Local::now().format("%Y-%m-%d_%H%M%S")));
                    fs::rename(filename, move_to)?;
                }
            }
            let mut f = fs::File::options().write(true).create(true).open(filename)?;
            write!(f, "{}", self)?;
            f.flush()?;
            Ok(())
        } else {
            Err(Box::new(SyncthingError::FilenameRequired))
        }
    }
}

fn ls(path: &PathBuf, include_dir: bool, include_files: bool) -> Result<HashSet<String>, Box<dyn Error>> {
    let mut results = HashSet::new();
    for entry in fs::read_dir(path)? {
        let existing = entry?.path();
        if include_dir && existing.is_dir() || include_files && existing.is_file() {
            if let Some(file_name) = existing.file_name() {
                if let Some(s) = file_name.to_str() {
                    results.insert(s.to_string());
                }
            }
        }
    }
    Ok(results)
}